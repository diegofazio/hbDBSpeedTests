/* $Id$ */

      Leto DB Server - это многоплатформенный сервер БД, или СУБД, 
 в основном предназначенный для клиентских программ, написанных на языке Harbour,
 для доступа к файлам dbf/cdx, расположенным на удаленном сервере.

Содержание
--------

1. Структура каталогов
2. Сборка letodb
   2.1 Компилятор Borland Win32 C
   2.2 Компилятор Linux GNU C
   2.3 xHarbour Builder
   2.4 Компилятор Mingw C
   2.5 Сборка letodb с помощью hbmk
   2.6 Поддержка дополнительных функций
3. Запуск и остановка сервера
4. Конфигурирование сервера
   4.1 letodb.ini
   4.2 Авторизация пользователей
5. Особенности работы с сервером
   5.1 Соединение с сервером клиентских программ
   5.2 Работа с фильтрами
6. Управление переменными
7. Список функций
   7.1 Управление соединением
   7.2 Работа с транзакциями
   7.3 Дополнительные функции для текущей рабочей области
   7.4 Дополнительные функции rdd
   7.5 Настройка параметров клиента
   7.6 Файловые функции
   7.7 Функции управления
   7.8 Функции управления пользователями
   7.9 Функции управления переменными сервера
   7.10 Вызов udf-функций на сервере
   7.11 Функции работы с bitmap фильтрами.
8. Утилита управления сервером
9. Функции, выполняемые на сервере


      1. Структура каталогов

      bin/          -    исполняемый файл сервера
      doc/          -    документация
      include/      -    файлы заголовков
      lib/          -    библиотека rdd
      source/
          client/   -    исходные тексты rdd
          common/   -    общие исходные тексты для сервера и rdd
          client/   -    исходные тексты сервера
      tests/        -    тестовые программы, примеры
      utils/
          manage/   -    исходные тексты утилиты управления сервером


      2. Сборка letodb

      Сервер letodb может быть собран только компилятором Harbour, а клиентская
 библиотека - как Harbour, так и xHarbour. Для ОС Windows сервер letodb может быть
 собран  как служба Windows (должен быть инициализирован макрос __WIN_SERVICE__),
 или как демон (процесс), для чего надо установить макрос __WIN_DAEMON__.
 Для сборки под  Linux надо установить макрос __LINUX_DAEMON__. 
      Сервер и клиентская библиотека могут быть собраны с поддержкой драйвера
 BMDBFCDX/BMDBFNTX. В этом случае базовыми rdd для сервера letodb будут использоваться
 вместо DBFCDX/DBFNTX  драйвера BMDBFCDX/BMDBFNTX, и будет поддерживаться функциональность,
 аналогичная BMDBF*.  Для сборки в этом режиме необходимо в скриптах сборки
 (letodb.hbp, rddleto.hbp для hbmk2 и makefile.* для остальных компиляторов)
 установить макрос __BM.  Для этого необходимо вызвать hbmk2 с опцией -env:
 hbmk2 -env:__BM=yes letodb.hbp
 hbmk2 -env:__BM=yes rddleto.hbp
      Для сборки сервера с поддержкой функций leto_Zip и leto_Unzip необходимо установить 
 макрос __ZIP:
 hbmk2 -env:__ZIP=yes letodb.hbp

      2.1 Компилятор Borland Win32 C

      Переменная окружения HB_PATH, в которой устанавливается путь к каталогу
 Harbour, должна быть установлена перед компиляцией. Это можно сделать,
 к примеру, добавив строку в make_b32.bat:

          SET HB_PATH=c:\harbour

 Если Вы используете xHarbour, снимите комментарий со строки 'XHARBOUR = yes' в makefile.bc.
 Затем запустите make_b32.bat, и исполняемый файл сервера letodb.exe будет создан в каталоге bin/,
 а библиотека rdd rddleto.lib - в каталоге lib/.

      2.2 Компилятор Linux GNU C

      Переменная окружения HB_ROOT, в которой устанавливается путь к каталогу
 Harbour, должна быть установлена перед компиляцией. Или просто измените
 значение HRB_DIR в файле Makefile.linux.

 Затем запустите make_linux.sh, и исполняемый файл сервера letodb будет создан
 в каталоге bin/, а библиотека rdd librddleto.a - в каталоге lib/.

      2.3 xHarbour Builder

      Запустите make_xhb.bat для сборки letodb этим компилятором. Возможно,
  необходимо будет изменить путь к xHarbour Builder в make_xhb.bat.
  Значение пути к xHarbour Builder по умолчанию:

          set XHB_PATH=c:\xhb

      2.4 Компилятор Mingw C

      Переменная окружения HB_PATH, в которой устанавливается путь к каталогу
 Harbour,  должна быть установлена перед компиляцией. Этот можно сделать,
 вставив строку в файл make_mingw.bat:

          SET HB_PATH=c:\harbour

 Если Вы используете xHarbour, снимите комментарий со строки 'XHARBOUR = yes'
 в файле makefile.gcc. Затем запустите the make_mingw.bat, и исполняемый файл
 сервера letodb.exe будет создан в каталоге bin/, а библиотека rdd 
 librddleto.a - в каталоге lib/.

      2.5 Сборка letodb с помощью hbmk

      Сейчас появилась возможность собрать letodb с помощью утилиты сборки Harbour,
 написанной Viktor Szakats. Синтаксис командной строки для сборки:

      hbmk2 [-hb10|-xhb] rddleto.hbp letodb.hbp [-target=tests/test_ta.prg]

 Дополнительные параметры: -hb10 - Harbour version is 1.0 or 1.0.1,
                      -xhb - xHarbour,
                      -target="blank"\test_ta.prg - сборка тестовых примеров.

      2.6 Поддержка дополнительных функций

      Сервер letodb для вычисления значения ключа в индексных выражениях и фильтра
 использует вычислитель Harbour и допускает вызов следующих функций:

      ABS, ALLTRIM, AT, CHR, CTOD, DATE, DAY, DELETED, DESCEND, DTOC, DTOS,
      EMPTY, I2BIN, L2BIN, LEFT, LEN, LOWER, LTRIM, MAX, MIN, MONTH, PAD, PADC,
      PADL, PADR, RAT, RECNO, RIGHT, ROUND, RTRIM, SPACE, STOD, STR, STRZERO,
      SUBSTR, REPLICATE, TIME, TRANSFORM, TRIM, UPPER, VAL, YEAR,
      hb_ATokens, hb_WildMatch

      Если этот набор функций необходимо дополнить, то в модуль source/server.prg
следует добавить строку:

      REQUEST <cFName1>[, ...]

      И пересобрать сервер.

      3. Запуск и остановка сервера

      Просто запустите:
      
      letodb.exe                    ( под Windows )
      ./letodb                      ( под Linux )

      Для останова сервера запустите тот же исполняемый файл с параметром
 'stop':

      letodb.exe stop               ( под Windows )
      ./letodb stop                 ( под Linux )

      Для перезагрузки модуля letoudf.hrb, запустите исполняемый файл с параметром 'reload':

      letodb.exe reload             ( under Windows )
      ./letodb reload               ( under Linux )

      Служба Windows (сервер должен быть собран с флагом __WIN_SERVICE__):

      Для установки и удаления службы необходимы права администратора.
      Для установки службы вызовите letodb с параметром 'install':

      letodb.exe install

      Для удаления службы, вызовите letodb с параметром 'uninstall':

      letodb.exe uninstall

      Запуск и останов службы выполняется из менеджера служб.

      4. Конфигурирование сервера

      4.1 letodb.ini

      Если Вас не устраивают параметры по умолчанию, Вы можете установить
 значения переменных конфигурации в файле letodb.ini. В настоящее время
 существуют следующие параметры конфигурации ( указаны значения по умолчанию ),
 они могут быть прописаны в секции [MAIN]:

      [MAIN]
      Port = 2812              -    порт сервера;
      Ip =                     -    ip адрес сервера; если он не указан, то сервер
                                    использует все сетевые интерфейсы (все ip адреса),
                                    имеющиеся у компьютера;
      TimeOut = -1             -    таймаут для соединения;
      DataPath =               -    путь к базе данных на сервере;
      LogPath = letodb.log     -    путь и имя лог-файла;
      Default_Driver = CDX     -    RDD по умолчанию для открытия файлов на сервере ( CDX/NTX );
      Memo_Type =              -    тип мемо ( FPT/DBT ). По умолчанию: FPT для DBFCDX, DBT для DBFNTX;
      Lower_Path = 0           -    если 1, преобразовать все пути к нижнему регистру;
      EnableFileFunc = 0       -    если 1, разрешено использование файловых функций
                                    ( leto_file(), leto_ferase(), leto_frename();
      EnableAnyExt = 0         -    если 1, разрешено создание таблиц данных и индексов с расширением,
                                    отличным от стандартного ( dbf,cdx,ntx );
      EnableUDF = 1            -    если 1 (по умолчанию), разрешено использование udf-функций с префиксом "UDF_",
                                    если 2, разрешено использование udf-функций с любыми именами,
                                    если 0, вызовы udf-функций запрещены;
      Pass_for_Login = 0       -    если 1, необходима авторизация пользователя
                                    для соединения с сервером;
      Pass_for_Manage = 0      -    если 1, необходима авторизация пользователя для
                                    использования функций управления сервером
                                    ( Leto_mggetinfo(), etc. );
      Pass_for_Data = 0        -    если 1, необходима авторизация пользователя для
                                    модификации данных;
      Pass_File = "leto_users" -    путь и имя файла информации пользователей;
      Crypt_Traffic = 0        -    если 1, то данные, передаваемые по сети, шифруются;
      Share_Tables  = 0        -    если 0 (по умолчанию, этот режим существует с момента
                                    старта проекта letodb), letodb открывает все таблицы
                                    в монопольном режиме, что позволяет увеличить
                                    производительность. Если 1 (новый режим, добавлен после 11.06.2009),
                                    таблицы открываются в том режима, в каком их открывает
                                    клиентское приложение, монопольном или режиме разделения, что
                                    позволяет letodb работать совместно с другими приложениями.
      No_Save_WA = 0           -    Когда этот режим установлен, при каждом вызове dbUseArea()
                                    сервер действительно открывает файл и создает новую рабочую
                                    область (workarea) - в режиме по умолчанию каждый
                                    файл открывается сервером только один раз и образуется одна
                                    реальная рабочая область для этого файла для всех клиентов.
                                    Теоретически это режим может увеличить производительность
                                    при большом количестве активных клиентов, но он недостаточно
                                    тестировался, поэтому для рабочих приложений рекомендуется
                                    использовать режим по умолчанию.
      Cache_Records            -    Кол-во записей, читаемых за один раз (в кэш клиента)
      Max_Vars_Number = 10000  -    Максимальное количество разделяемых переменных
      Max_Var_Size = 10000     -    Максимальный размер текстовой переменной
      Trigger = <cFuncName>    -    Глобальная функция letodb RDDI_TRIGGER
      PendingTrigger = <cFuncName>- Глобальная функция letodb RDDI_PENDINGTRIGGER
      EnableSetTrigger = 0     -    если 1, разрешает изменять установки триггера
                                    с помощью dbInfo( DBI_TRIGGER, ... )
      Tables_Max  = 5000       -    Количество таблиц
      Users_Max = 500          -    Количество пользователей
      Debug = 0                -    Уровень отладки
      Optimize = 0             -    если 1, SET HARDCOMMIT OFF
      AutOrder = 0             -    настройка для SET AUTORDER
      ForceOpt = 0             -    настройка для _SET_FORCEOPT

      Возможно определить секцию [DATABASE], если Вы хотите указать каталог БД,
 в котором таблицы должны открываться другим RDD:

      [DATABASE]
      DataPath =               -    (обязательная опция)
      Driver = CDX             -    ( CDX/NTX )

      Можно определить столько секций [DATABASE], сколько необходимо.

      В Windows файл letodb.ini должен быть размещен в том каталоге, в
 котором находится сервер letodb.
      В Linux сервер ищет этот файл в том каталоге, откуда он стартовал,
 или, при неудаче, в каталоге /etc.

      4.2 Авторизация пользователей

      Чтобы включить подсистему авторизации, необходимо установить один из следующих параметров
 letodb.ini в 1: Pass_for_Login, Pass_for_Manage, Pass_for_Data. Но перед этим
 необходимо создать, как минимум, одного пользователя с правами администратора, поскольку когда
 система авторизации работает, только авторизованные пользователи с правами администратора могут
 добавлять/изменять пользователей и пароли.
      Чтобы добавить пользователя, необходимо включить вызов функции LETO_USERADD() в клиентскую
 программу, к примеру:

      LETO_USERADD( "admin", "secret:)", "YYY" )

 где "YYY" это строка, которая дает права администрирования, управления и права на запись. Вы можете
 также использовать программу utils/manager/console.prg, чтобы установить или изменить данные авторизации.

 Для соединения с сервером с данными авторизации ( именем пользователя и паролем) необходимо
 вызвать функцию LETO_CONNECT().

      5. Соединение с сервером клиентских программ

      Чтобы сконнектиться с сервером, прежде всего необходимо прилинковать библиотеку rddleto
 к своему приложению, и добавить в начале своей программы две строки:

      REQUEST LETO
      RDDSETDEFAULT( "LETO" )

      Для открытия файла dbf на сервере необходимо вставить в оператор SET PATH TO,
 или в команду USE путь к серверу в стандартной форме:
 //ip_address:port/data_path/file_name.

      Если задан параметр 'DataPath' в конфигурационном файле сервера, и он имеет
 непустое значение, необходимо указывать не полный путь к файлу на сервере,
 а путь относительный ( относительно значению 'DataPath' ).
      Например, если необходимо открыть файл test.dbf, который расположен на
 сервере 192.168.5.22 в каталоге /data/mydir и значение параметра 'DataPath'
 ( в файле конфигурации сервере letodb.ini ) '/data', синтаксис должен быть
 таким:

      USE "//192.168.5.22:2812/mydir/test"

      Если сервер не запущен или Вы указали неверный путь, будет сгенерирована ошибка открытия.
 Возможно проверить доступность сервера перед открытием файлов вызовом функции
 leto_Connect( cAddress ), которая вернет -1 в случае неудачной попытки:

      IF leto_Connect( "//192.168.5.22:2812/mydir/" ) == -1
         Alert( "Can't connect to server ..." )
      ENDIF

      При соединении с сервером клиент передает ему информацию о кодовой странице, которую
сервер затем использует для операций индексации, фильтрации и для некоторых других операций.
Кодовая страница на клиенте должна быть установлена до соединения с сервером letodb.

      5.2 Работа с фильтрами

      Фильтр устанавливается обычным образом: с помощью команды SET FILTER TO или вызовом
функции dbSetFilter(). Фильтр, который может быть выполнен на сервере, называется оптимизированным.
Если фильтр не может быть выполнен на сервере, он является неоптимизированным. Такой фильтр
является медленным, поскольку с сервера все равно запрашиваются все записи, которые затем
фильтруются на клиенте. Чтобы задать оптимизированный фильтр, необходимо, чтобы в логическом
выражении для фильтра отсутствовали переменные или функции, определенные на клиенте.
Чтобы проверить, является ли фильтр оптимизированным, надо вызвать функцию LETO_ISFLTOPTIM().

      6. Управление переменными

      Letodb позволяет создавать переменные, которые разделяются между приложениями,
 которые соединились с сервером. Переменные можно разбить на группы, и они могут иметь логический,
 целый или символьный тип. Можно установить значение переменной, получить его, удалить, или вызвать
 инкремент/декремент ( числовой переменной, естественно ). Все операции с переменными выполняются
 последовательно в одном потоке, так что переменные могут использоваться как семафоры. См. список
 функций для синтаксиса нужной функции, и пример tests/test_var.prg.
      Файл Letodb.ini может содержать строку для определения максимального количества переменных
 и максимальной длины текстовой переменной.

      7. Список функций

      Ниже приведен полный ( на момент написания ) список функций,
 доступных для использования в клиенском приложении с прилинкованным RDD LETO.

      7.1 Управление соединением

      LETO_CONNECT( cAddress, [ cUserName ], [ cPassword ], [ nTimeOut ], [ nBufRefreshTime ] )
                                                           --> nConnection, -1 при неудаче
 nBufRefreshTime определяет интервал в 0.01 сек. По истечении этого интервала
 буфер для записей будет обновлен. Значение по умолчанию 100 (1 сек)

      LETO_CONNECT_ERR()                                   --> nError
      LETO_DISCONNECT( [ cConnString | nConnection ] )     --> nil
      LETO_SETCURRENTCONNECTION( [ cConnString | nConnection ] ) --> nConnection
      LETO_GETCURRENTCONNECTION()                          --> nConnection
      LETO_GETSERVERVERSION()                              --> cVersion
      LETO_GETLOCALIP()                                    --> IP адрес клиента
      LETO_ADDCDPTRANSLATE(cClientCdp, cServerCdp )        --> nil
      LETO_PATH( [<cPath>], [cConnString | nConnection] )  --> cOldPath
      LETO_PING( [ cConnString | nConnection ] )           --> lResult

      7.2 Работа с транзакциями

      LETO_BEGINTRANSACTION( [ nBlockLen ], [ lParseTrans ] )
 Параметр <nBlockLen> используется для зарания размера блока для выделения памяти.
 Для больших транзакций таким образом можно существенно ускорить выполнение транзакции
 на стороне клиента.
 Если значение параметра <lParseTransRec> равно .F., буфер транзакции не обрабатывается
 во время получения записей с сервера.

      LETO_ROLLBACK()

      LETO_COMMITTRANSACTION( [ lUnlockAll ] )             --> lSuccess

      LETO_INTRANSACTION()                                 --> lTransactionActive

      7.3 Дополнительные функции для текущей рабочей области

      LETO_COMMIT()
 Эта функция может использоваться для текущей рабочей области вместо вызова функций:

 dbCommit()
 dbUnlock()

 Клиент отправляет серверу 3 пакета: для обновления текущей записи, для сброса текущей
 записи на диск и для снятия блокировки рабочей области. Leto_Commit отправляет только
 один пакет для выполнения этих операций

      LETO_SUM( <cFieldNames>|<cExpr>, [ cFilter ], [xScope], [xScopeBottom] )
                                                           --> nSumma - если передано одно поле или выражение, или
                                                               {nSumma1, nSumma2, ...} для нескольких полей
 Первый параметр leto_sum это список полей или выражений, разделенных запятой:
 leto_sum("Sum1,Sum2", cFilter, cScopeTop, cScopeBottom) возвращает
 массив с суммами полей Sum1 и Sum2.

 Если в качестве имени поля передан символ "#", leto_sum возвращает количество обработанных записей:
 leto_sum("Sum1,Sum2,Sum1+Sum2,#", cFilter, cScopeTop, cScopeBottom) -->
 {nSum1, nSum2, nSum3, nCount}

 Если функции передано только одно имя поля, она возвращает числовое значение суммы этого поля

      LETO_GROUPBY(cGroup, <cFields>|<cExpr>, [cFilter], [xScopeTop], [xScopeBottom]) --> aValues

 Эта функция возвращает двумерный массив. Первый элемент каждой строки - это
 значение поля <cGroup>, элементы со 2-го - сумма полей или выражений,
 разделенных запятой, заданных в параметре <cFields>. Если символ "#" передан
 в качестве имени поля в <cFields>, leto_groupby возвращает количество записей
 в каждой группе.
                                                               {{xGroup1, nSumma1, nSumma2, ...}, ...}
      LETO_ISFLTOPTIM()                                    --> lFilterOptimized

      dbInfo( DBI_BUFREFRESHTIME[, nNewVal])               --> nOldVal
  Установка нового значения для времени обновления skip и seek буферов текущей
  рабочей области в 0.01 сек. Если -1: используется настройка для соединения.
  Если 0 - буфера используются постоянно.

      dbInfo( DBI_CLEARBUFFER )
  Команда очищает skip буфер.

      7.4 Дополнительные функции rdd

      leto_CloseAll( [ cConnString | nConnection ] )       --> nil
 Закрывает все рабочие области для указанного соединения или соединения по умолчанию

      7.5 Настройка параметров клиента

      LETO_SETSKIPBUFFER( nSkip )                          --> nCount (статистика использования буфера)
 Skip-буфер предназначен для оптимизации множественных вызовов skip
 Эта функция задает размер в записях для skip-буфера для текущей рабочей области.
 По умолчанию размер skip-буфера 10 записей. Skip-буфер является двунаправленным.
 skip-буфер сбрасывается после BUFF_REFRESH_TIME (1 сек)
 Если параметр функции опущен, она возвращает статистику использования буфера (количество попаданий)

      LETO_SETSEEKBUFFER( nRecsInBuf )                     --> nCount (статистика использования буфера)
 Seek буфер предназначен для оптимизации множественных вызовов seek
 Эта функция задает размер в записях для seek-буфера для текущего индекса.
 Если запись найдена в буфере при выполнении dbSeek(), она не загружается с сервера.
 Подобно skip-буферу, seek-буфер сбрасывается после BUFF_REFRESH_TIME (1 сек)
 Если параметр функции опущен, она возвращает статистику использования буфера (количество попаданий)
 По умолчанию, seek-буфер выключен.

      LETO_SETFASTAPPEND( lFastAppend )                    --> lFastAppend (предыдущее значение)
 Если не задан режим fast append, то запись добавляется на сервере сразу
 после вызова функции dbAppend(). Если этот режим задан, то запись добавляется
 при вызове dbCommit(), либо после вызова функций навигации. По умолчанию режим
 fast append не задан. Действие этой установки распространяется на все рабочие области

      RddInfo( RDDI_REFRESHCOUNT, <lSet>,, [nConnection] )
 По умолчанию флаг RDDI_REFRESHCOUNT установлен. Если он установлен, функция
 RecCount() запращивает значение количества записей с сервера, если не установлен -
 использует последнее значение, полученное с сервера. Если другое приложение
 добавляет записи в теблицу, то значение количества записей не может быть получено
 сразу.
 Если флаг RDDI_REFRESHCOUNT не установлен, dbGoto(0) очищает буфер записи и
 устанавливает флаги eof и другие вместо запроса к серверу.

      RddInfo( RDDI_BUFKEYCOUNT, <lSet>,, [nConnection] )
 По умолчанию флаг RDDI_BUFKEYCOUNT не установлен. Если он не установлен, функция
 ordKeyCount() запращивает значение количества ключей с сервера, если установлен -
 использует последнее значение, полученное с сервера.

      RddInfo( RDDI_BUFKEYNO, <lSet>,, [nConnection] )
 По умолчанию флаг RDDI_BUFKEYNO не установлен. Если он не установлен, функция
 ordKeyNo() запращивает значение сервера, если установлен -
 использует последнее значение, полученное с сервера.

      RddInfo( RDDI_CLIENTID,,, [nConnection] )
 Возвращает собственный номер клиента (nUserStru).

      7.6 Файловые функции

 Параметр <cFileName> всех файловых функций может содержать строку коннекта
 к серверу letodb в формате:
 //ip_address:port/data_path/file_name.
 Если строка коннекта опущена, используется текущее активное соединение:
 /data_path/file_name.
 Все файлы располагаются относительно каталога DataPath на сервере. Использование
 папки ".." в имени запрещено.

      LETO_FILE( cFileName )                               --> lFileExists
 Проверяет существование файла на сервере, аналог функции File()

      LETO_FERASE( cFileName )                             --> -1 при неудаче
 Удаляет файл на сервере.

      LETO_FRENAME( cFileName, cFileNewName )              --> -1 при неудаче
 Переименовывает файл <cFileName> --> <cFileNewName>. cFileNewName должен быть
 указан без строки коннекта.

      LETO_MEMOREAD( cFileName )                           --> cStr
 Возвращает содержимое файла на сервере как символьную строку, аналог функции
 MemoRead()

      Leto_MemoWrite( cFileName, cBuf )                    --> lSuccess
 Записывает содержимое символьной строки в файл на сервере, аналог функции
 MemoWrit()

      LETO_MAKEDIR( cDirName )                             --> -1 при неудаче
 Создает каталог на сервере

      LETO_DIREXIST( cDirName )                            --> lDirExists
 Проверяет существование каталога на сервере

      LETO_DIRREMOVE( cDirName )                           --> -1 при неудаче
 Удаляет каталог на сервере

      LETO_FERROR()                                        --> nError
 Возвращает код ошибки последней файловой функции

      Leto_FileRead( cFileName, nStart, nLen, @cBuf )      --> -1 if failed
 Читает содержимое файла со смещения <nStart> размером <nLen>

      Leto_FileWrite( cFileName, nStart, cBuf )            --> lSuccess
 Записывает переменную <cBuf> в файл на сервере со смещения <nStart>

      Leto_FileSize( cFileName )                           --> -1 if failed
 Возвращает размер файла на сервере

      Leto_FileAttr( cFileName [, cNewAttr] )              --> cAttr
 Возвращает или устанавливает атрибуты файла на сервере

      Leto_Directory( cDir[, cAttr] )                      --> aDirectory
 Возвращает содержимое каталога на сервере в формате, аналогичном функции
 Directory()

      7.7 Функции управления

      LETO_MGGETINFO()                                     --> aInfo
 Эта функция возвращает параметры текущего соединения в виде массива из
 17 элементов символьного типа:
 1 - текущее к-во пользователей
 2 - максимальное к-во пользователей
 3 - текущее к-во открытых таблиц
 4 - максимальное к-во открытых таблиц
 5 - время работы сервера
 6 - к-во операций
 7 - байт отправлено
 8 - байт прочитано
 9 - текущее к-во открытых индексов
 10 - максимальное к-во открытых индексов
 11 - data path
 12 - max day wait
 13 - ulWait
 14 - общее к-во транзакций
 15 - к-во успешных транзакций
 16 - использовано памяти
 17 - максимально использовано памяти

      LETO_MGGETUSERS( [<cTableId>|<nTable>] )             --> aInfo
 Функция возвращает двумерный массив, каждая строка которого
 содержит информацию о пользователе:
 aInfo[i,1] - номер клиента
 aInfo[i,2] - ip адрес
 aInfo[i,3] - сетевое имя клиента
 aInfo[i,4] - имя программы
 aInfo[i,5] - таймаут

      LETO_MGGETTABLES( [<cUserId>|<nUser>] )              --> aInfo
 Функция возвращает двумерный массив, каждая строка которого
 содержит информацию об открытых таблицах:
 aInfo[i,1] - номер таблицы
 aInfo[i,2] - имя таблицы

      LETO_MGGETLOCKS( [<cUserId>|<nUser>] )               --> aInfo
 Функция возвращает двумерный массив, каждая строка которого
 содержит информацию о блокировках:
 aInfo[i,1] - имя таблицы
 aInfo[i,2] - строка со списком блокированных записей

      LETO_MGGETTIME()                                     --> aDateTime
 Функция возвращает массив {<dDate>, <nSeconds>}:
 dDate - дата сервера;
 nSeconds - секунд после полуночи.
 Для преобразования значения в переменную DateTime (Harbour) вызовите:
 hb_DTOT( aDateTime[1], aDateTime[2] )

      LETO_MGKILL( <nUser>|<cUserId> )
 Функция отключает пользователя с номером <nUser>

      LETO_LOCKCONN( lOnOff )                              --> lSuccess
 После вызова leto_lockconn( .t. ) все новые соединения блокируются сервером,
 до вызова leto_lockconn( .f. )

      LETO_LOCKLOCK( lOnOff, nSecs )                       --> lSuccess
 Эта функция ожидает завершения всех операций обновления данных, сброса всех
 измеенений, и пытается блокировать сервер от всех изменений с клиентов.
 Если попытка блокировки была успешной, функция возвращает True.

      7.8 Функции управления пользователями

      LETO_USERADD( cUserName, cPass [, cRights ] )        --> lSuccess
      LETO_USERPASSWD( cUserName, cPass )                  --> lSuccess
      LETO_USERRIGHTS( cUserName, cRights )                --> lSuccess
      LETO_USERFLUSH()                                     --> lSuccess
      LETO_USERGETRIGHTS()                                 --> cRights

      7.9 Функции управления переменными сервера

      LETO_VARSET( cGroupName, cVarName, xValue[, nFlags[, @xRetValue]] ) --> lSuccess

 Функция присваивает значение <xValue> переменной <cVarName> из группы <cGroupName>
 Необязательный параметр <nFlags> может задать режимы работы функции:
 LETO_VCREAT    - если переменной не существует, она будет создана;
 LETO_VOWN      - собственная переменная пользователя, освобождается после рассоединения;
 LETO_VDENYWR   - запрет присваивания значения другим пользователем;
 LETO_VDENYRD   - запрет чтения значения другим пользователем;
 LETO_VPREVIOUS - возврат предыдущего значения переменной в <xRetValue>.

      LETO_VARGET( cGroupName, cVarName )                  --> xValue

 Функция возвращает значение переменной <cVarName> из группы <cGroupName>

      LETO_VARINCR( cGroupName, cVarName )                 --> nValue

 Инкремент значения переменной <cVarName> из группы <cGroupName>

      LETO_VARDECR( cGroupName, cVarName )                 --> nValue

 Декремент значения переменной <cVarName> из группы <cGroupName>

      LETO_VARDEL( cGroupName, cVarName )                  --> lSuccess

 Удаление переменной <cVarName> из группы <cGroupName>

      LETO_VARGETLIST( [cGroupName [, nMaxLen]] )          --> aList

 Функция возвращает двумерный массив переменных: { {<cVarName>, <value>}, ...}

      7.10 Вызов udf-функций на сервере

      LETO_UDF( cSeverFunc, xParam1, ... )                 --> xResult
 Функция вызывается из клиентского приложения. Строка
 <cServerFunc> - строка с параметрами соединения сервера и именем
 udf-функции:
 //ip_address:port/funcname
 Функция <funcname> должна существовать на letodb сервере.
 Первый параметр udf-функции - nUserStru.
 Udf-функция может возвращать результат (любого типа) клиенту.
 Примеры udf-функций см. в tests/letoudf.prg

      LETO_UDFEXIST( cSeverFunc )                          --> lExist
 leto_udfExist проверяет, существует ли udf-функция на сервере letodb.
 Параметр <cSeverFunc> задается так же, как и для leto_udf().

      LETO_PARSEREC( cRecBuf )                             --> nil
 Эту функцию необходимо вызвать, если udf-функция возвращает в качестве
 результата буфер записи, которая должна быть текущей в результате ее
 работы.

      LETO_PARSERECODRS( cRecBuf )                         --> nil
 Эту функцию необходимо вызвать для заполнения skip-буфера как результат
 выполнения udf-функции UDF_dbEval. После вызова этой функции данные из
 skip-буфера выбираются вызовами функции dbSkip(). Пример см. в комментариях
 к UDF_dbEval в tests/letoudf.prg

      7.11 Функции работы с bitmap фильтрами.

 Если letodb собран с поддержкой rdd BMDBFCDX/BMDBFNTX, то имеется поддержка
 следующих функций:

      LBM_DbGetFilterArray()                               --> aFilterRec
      LBM_DbSetFilterArray( aFilterRec )                   --> nil
      LBM_DbSetFilterArrayAdd( aFilterRec )                --> nil
      LBM_DbSetFilterArrayDel( aFilterRec )                --> nil

 Назначение и параметры этих функций такое же, как у соответствующих функций BM_*.

      LBM_DbSetFilter( [<xScope>], [<xScopeBottom>], [<cFilter>] ) -> nil
 Функция устанавливает bitmap-фильтр для текущего индекса и по условию,
 определенному параметрами <xScope>, <xScopeBottom>, <cFilter>
 Текущая запись после вызова LBM_DbSetFilter() будет первой записью,
 удовлетворяющей условию фильтра.

      8. Утилита управления сервером

      Можно собрать две утилиты управления сервером, GUI и консольную. Исходные тексты
 находятся в каталоге utils/manage directory.

      Утилита GUI, manage.prg, создана с помощью библиотеки HwGUI. Если у Вас установлена HwGUI,
 вставьте строку 'set HWGUI_INSTALL=' в файл utils/manage/bld.bat путь к 
 каталогу HwGUI и запустите bld.bat. Утилита manage.exe будет собрана.
   
      Для тех, кто не использует HwGUI, есть утилита управления в режиме консоли,
 console.prg. Соберите console.exe с помощью файла make/bat, который Вы используете
 для сборки программы Harbour, состоящей из одного модуля. Необходимо только добавить
 rddleto.lib к списку библиотек. Запуститe console.exe с именем сервера или ip адресом
 и номером порта в качестве параметра:

      console.exe server_name:nPort
      console.exe ip_address:nPort

 server_name и ip_address в командной строке должен быть без ведущих слешей
 ( '//' ), поскольку Clipper/Harbour использует их для своих нужд.

      9. Функции, выполняемые на сервере

      Эти функции могут вызываться на выполнение с клиента с помощью функции
 leto_udf, а также из функций, определенных в файле letoudf.hrb. Первый параметр
 такой функции всегда nUserStru

      leto_Alias( nUserStru, cClientAlias )                --> cRealAlias
 Функция возвращает алиас сервера для клиентского алиаса <cClientAlias>.
 Алиас сервера затем может использоваться в обычных rdd-операциях

      leto_RecLock( nUserStru [, nRecord] )                --> lSuccess
 Функция leto_RecLock блокирует запись с номером <nRecord>, или текущую запись

      leto_RecUnLock( nUserStru [, nRecord] )              --> Nil
 Функция leto_UnRecLock снимает блокировку с записи номер <nRecord>, или с
 текущей записи

      leto_RecLockList( nUserStru, aRecNo )                --> lSuccess
 Функция leto_RecLockList блокирует записи с номерами, указанными в массиве
 aRecNo. Если блокировка какой-либо записи не удалась, блокировки снимаются,
 и возвращается результат .F.
      Эту функцию можно вызывать на сервере в модуле letoudf.prg, или с клиента
 вызовом leto_UDF( "leto_RecLockList", aRecNo )

      leto_TableLock( <nUserStru>, [<nFlag>], [<Secs>])    --> lSuccess
      leto_TableUnLock( <nUserStru>, [<nFlag>])

      nFlag - параметр от 1 до 32, nSecs - секунд ожидания блокировки (1 по умолчанию)
      Эти функции предназначены для обеспечения конкуррентного доступа к таблице
      для действий кроме обновления данных.

      leto_SelectArea( nUserStru, nAreaId )                --> lSuccess

      leto_areaID( nUserStru )                             --> nAreaId
 Функция возвращает внутренний номер id для текущей рабочей области

      leto_ClientID()                                      --> nUserStru
 Функция возвращает номер клиента (nUserStru), -1 при неудаче

      letoUseArea( nUserStru, cFileName, cAlias, lShared, lReadOnly, cdp ) --> nAreaId
      letoOrdListAdd( nUserStru, cBagName )                --> Nil
      letoOrdCreate( nUserStru, cBagName, cKey, cTagName,
                     lUnique, cFor, cWhile, lAll, nRecNo,
                     nNext, lRest, lDesc, lCustom,
                     lAdditive )                           --> Nil
      letoCloseArea( nUserStru )                           --> Nil

 Функции letoUseArea, letoOrdListAdd, letoOrdCreate, letoCloseArea,
 leto_RecLock, leto_RecLock предназначены для использования в udf-функциях вместо
 rdd функций: dbUseArea, OrdListAdd, OrdCreate, dbCloseArea, RLock, dbUnlock

 Функции управления переменными сервера:

      LETO_VARSET( nUserStru, cGroupName, cVarName, xValue[, nFlags )
                                                           --> lSuccess
      LETO_VARGET( nUserStru, cGroupName, cVarName )       --> xValue
      LETO_VARINCR( nUserStru, cGroupName, cVarName )      --> nValue
      LETO_VARDECR( nUserStru, cGroupName, cVarName )      --> nValue
      LETO_VARDEL( nUserStru, cGroupName, cVarName )       --> lSuccess
      LETO_VARGETLIST( nUserStru, [cGroupName, [lValue]] ) --> aList

 Zip/Unzip функции:

      leto_Zip( nUserStru, [cDirName], [acFiles], [nLevel], [lOverwrite], [cPassword], [acExclude], [lWithPath] )
                                                           --> cZip
      leto_UnZip( nUserStru, [cDirName], cZip, [cPassword], [lWithPath] )   --> lSuccess
 где:
 cDirName - каталог относительно DataPath;
 cZip - содержимое архива для распаковки;
 остальные параметры соответствуют параметрам функций hb_ZipFile/hb_UnZipFile.
 Вызов функций с клиента:
 leto_UDF("leto_Zip", [cDirName], ...)
 leto_UDF("leto_UnZip", [cDirName], cZip, ...)
